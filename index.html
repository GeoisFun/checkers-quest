<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Checkers</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
    }
    .board {
      display: grid;
      grid-template-columns: repeat(8, 50px);
      grid-template-rows: repeat(8, 50px);
      gap: 1px;
      margin: 20px auto;
      width: 420px;
      height: 420px;
    }
    .cell {
      width: 50px;
      height: 50px;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: rgb(13, 163, 41);
    }
    .cell.black {
      background-color: #EEE;
    }
    .piece {
      width: 30px;
      height: 30px;
      border-radius: 50%;
    }
    .red {
      background-color: red;
    }
    .red_kg {
      background-color: rgb(255, 129, 146);
    }
    .black-piece {
      background-color: black;
    }
    .black_kg {
      background-color: rgb(99, 99, 99);
    }
  </style>
</head>
<body>
  <h1>Welcome to Andy's Checkers!</h1>
  <div class="board" id="board"></div>

  <script>
    let board = [];
    let currentPlayer = -1; // 1 for bot (black), -1 for human (red)
    let selectedPiece = null;
    let forcedCapture = false;
    let forcedPiece = null;
    let possibleDestinations = [];
    ///////////////////Implement King Checker on Frontend
    
    // Fetch initial board state from backend
    function getBoard() {
      fetch('/get_board')
        .then(response => response.json())
        .then(data => {
          board = data;
          renderBoard();
        })
        .catch(error => console.error('Error fetching board:', error));
    }

    // Render the board on the frontend
    function renderBoard() {
      const boardContainer = document.getElementById('board');
      boardContainer.innerHTML = ''; // Clear previous board rendering

      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          if ((row + col) % 2 === 1) cell.classList.add('black'); // Checkered pattern

          if (board[row][col] !== 0) {
            const piece = document.createElement('div');
            piece.classList.add('piece');
            if (board[row][col] === 1) {
              piece.classList.add('black-piece');
            } else if (board[row][col] === 2) {
              piece.classList.add('black_kg');
            }else if (board[row][col] === -1) {
              piece.classList.add('red');
            }else if (board[row][col] === -2) {
              piece.classList.add('red_kg');
            }
            cell.appendChild(piece);
          }

          // Attach event listeners to cells
          cell.setAttribute('data-row', row);
          cell.setAttribute('data-col', col);
          cell.addEventListener('click', handleClick);
          boardContainer.appendChild(cell);
        }
      }
    }

    // Handle cell click (selecting and moving pieces)
    function handleClick(event) {
      const cell = event.target.closest('.cell');
      if (!cell) return;

      const row = parseInt(cell.getAttribute('data-row'));
      const col = parseInt(cell.getAttribute('data-col'));
      if (isNaN(row) || isNaN(col)) return;

      if (!selectedPiece) {
        // Selecting a piece
        if (board[row][col] === currentPlayer) {
          selectedPiece = { row, col };
        }
        else if (board[row][col] === 2*currentPlayer) {
          selectedPiece = { row, col };
        }
      } else {
        // Moving the selected piece
        let piece = board[selectedPiece.row][selectedPiece.col];
        movePiece(selectedPiece, { row, col }, piece);
        if (Math.abs(selectedPiece.row-row) == 2 && Math.abs(selectedPiece.col-col == 2)) {
          let nextCaptures = canCaptureAgain(row, col, piece);

          if (nextCaptures && nextCaptures.length > 0) {
            forcedCapture = true;
            forcedPiece = { row, col };
            possibleDestinations = nextCaptures;
          }
        }
      
      }
      if (forcedCapture) {
            // We're in forced capture mode
            if (row === forcedPiece.row && col === forcedPiece.col) {
              // Player clicked current piece again to end capturing
              forcedCapture = false;
              forcedPiece = null;
              possibleDestinations = [];
              return;
            }

            // Check if clicked square is a valid next capture
            for (let dest of possibleDestinations) {
              if (dest.row === row && dest.col === col) {
                let piece = board[forcedPiece.row][forcedPiece.col];
                movePiece(forcedPiece, { row, col }, piece);
                let nextCaptures = canCaptureAgain(row, col, piece);

                if (nextCaptures && nextCaptures.length > 0) {
                  forcedCapture = true;
                  forcedPiece = { row, col };
                  possibleDestinations = nextCaptures;
                } else {
                  forcedCapture = false;
                  forcedPiece = null;
                  possibleDestinations = [];
                }
                return;
              }
            }
            // Clicked an invalid square â€” ignore
            return;
      }
      selectedPiece = null; // Reset selected piece after move 
    }

      
    
    function inBounds(x,y) {
      if (0 <= x <= 7 && 0 <= y <= 7) {
        return true
      }
      return false
    }
    
    // Move the piece (validate and send to backend)
    function canCaptureAgain(row, col, piece) {
      //varies on first and red is neg/black pos
      const directions = [[-2, -2], [-2, 2], [2, -2], [2, 2]];
      let piece_direc = null
      if (piece == -1) {
        piece_direc = [directions[0], directions[1]]
      } else if (piece == 1) {
        piece_direc = [directions[2], directions[3]]
      } else {
        piece_direc = directions
      }

      let move_list = []
      for (direction in directions) {
        //CHECK IF BOARD IS UPDATED PROPERLY ELSE BOARD FUNCTION USED HERE WILL NOT WORK
        if (inBounds(row + direction[0], col + direction[1])) {
          if (board[row + direction[0]][col + direction[1]] == 0 && board[row + (direction[0])/2][col + (direction[1])/2] == Math.sign(-1*piece)) {
            move_list.push([row + direction[0], col + direction[1]])
          }
        }
      }
      if (move_list.length == 0) {
        return false
      } else {
        return move_list
      }
    }

    async function isValidMove(from, to, piece, special_case = null) {
      const response = await fetch("/send-value", {
          method: "POST",
          headers: {
              "Content-Type": "application/json"
          },
          body: JSON.stringify({ board: board })
      });

      const available_moves = await response.json();

      if (Math.abs(from[0]-to[0]) == 2 && Math.abs(from[1]-to[1]) == 2) {
        move = [[from[0], from[1]], [to[0], to[1]], [(from[0]+to[0])/2, (from[1]+to[1])/2], null, null]

      } else if (Math.abs(from[0]-to[0]) == 1 && Math.abs(from[1]-to[1]) == 1) {
        //Nulling the 1st, 2nd, 3rd captures because this is only for normal moves, no captures
        move = [[from[0], from[1]], [to[0], to[1]], null, null, null]

      } else {
        return false
      }
      
      // console.log(available_moves, "available")

      //Check if none turns into null properly 
      if (move in available_moves) {
        return true
      }
      //console.log(move in available_moves)

      return false;
    }

    function movePiece(from, to, piece) {
      
      if (Math.abs(from[0]-to[0]) == 1 && Math.abs(from[1]-to[1]) == 1) {
        //Normal, non-capture move
        if (isValidMove(from, to, piece)) {

          // UPDATES BOARD for frontend
          board[from[0]][from[1]] = 0
          board[to[0]][to[1]] = piece

          // Send move to the backend
          fetch("/move", {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              board: board,
              player: currentPlayer
            })
          })
          .then(response => response.json())
          .then(data => {
            if (data.board) {
              board = data.board; // Update board from server response
              renderBoard();
              moves = data.move;
            } else {
              console.log("Move failed: ", data.message || "Unknown error");
            }
          })
          .catch(error => console.error("Error making move:", error));
        } else {
          console.log("Invalid move!");
        }

      } else if (Math.abs(from[0]-to[0]) == 2 && Math.abs(from[1]-to[1]) == 2) {
          if (isValidMove(from, to, piece)){
  
                //updating board
                board[from[0]][from[1]] = 0
                board[(from[0]+to[0])/2][(from[1]+to[1])/2] = 0
                board[to[0]][to[1]] = piece

                // Send move to the backend
                fetch("/move", {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json"
                  },
                  body: JSON.stringify({
                    board: board,
                    player: currentPlayer
                  })
                })
                .then(response => response.json())
                .then(data => {
                  if (data.board) {
                    board = data.board; // Update board from server response
                    renderBoard();
                    moves = data.move;
                  } else {
                    console.log("Move failed: ", data.message || "Unknown error");
                  }
                })
                .catch(error => console.error("Error making move:", error));
              
          } else {
            console.log("Invalid move!");
          }
        
      } else {
        console.log("Invalid move! or Please try capturing the pieces one at a time, you can chain capture, but only move by move");
      }
    }
    // Start the game and render the initial board
    getBoard();
  </script>
</body>
</html>
